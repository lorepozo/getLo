{"version":3,"file":"/packages/force-ssl.js","sources":["force-ssl/force_ssl_common.js","force-ssl/force_ssl_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,4D;;;;;;;;;;;;;;;;;;;ACAA,6D;AACA,yD;AACA,gE;AACA,gD;AACA,uG;;AAEA,mC;AACA,sE;AACA,yC;AACA,uD;;AAEA,+D;AACA,oE;AACA,kC;AACA,I;AACA,sE;AACA,sE;AACA,6C;;AAEA,qB;AACA,iE;AACA,gE;AACA,mE;AACA,e;AACA,qD;AACA,iB;AACA,0C;AACA,yC;AACA,sE;AACA,wC;AACA,Y;;AAEA,qE;AACA,iE;AACA,oC;AACA,0C;AACA,iE;;AAEA,2B;AACA,mD;;AAEA,sE;AACA,uC;AACA,iC;AACA,oD;;AAEA,mE;AACA,8D;AACA,qC;;AAEA,wB;AACA,6C;AACA,O;AACA,c;AACA,W;AACA,G;;AAEA,wC;AACA,uB;AACA,wD;AACA,wC;AACA,K;AACA,G;;;AAGA,wC;AACA,E;AACA,sE;AACA,qE;AACA,kE;AACA,mE;AACA,sC;AACA,E;AACA,oE;AACA,c","sourcesContent":["_.extend(Meteor.absoluteUrl.defaultOptions, {secure: true});\n","// Unfortunately we can't use a connect middleware here since\n// sockjs installs itself prior to all existing listeners\n// (meaning prior to any connect middlewares) so we need to take\n// an approach similar to overshadowListeners in\n// https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee\n\nvar httpServer = WebApp.httpServer;\nvar oldHttpServerListeners = httpServer.listeners('request').slice(0);\nhttpServer.removeAllListeners('request');\nhttpServer.addListener('request', function (req, res) {\n\n  // allow connections if they have been handled w/ ssl already\n  // (either by us or by a proxy) OR the connection is entirely over\n  // localhost (development mode).\n  //\n  // Note: someone could trick us into serving over non-ssl by setting\n  // x-forwarded-for or x-forwarded-proto. Not much we can do there if\n  // we still want to operate behind proxies.\n\n  var remoteAddress =\n        req.connection.remoteAddress || req.socket.remoteAddress;\n  // Determine if the connection is only over localhost. Both we\n  // received it on localhost, and all proxies involved received on\n  // localhost.\n  var localhostRegexp = /^\\s*(127\\.0\\.0\\.1|::1)\\s*$/;\n  var isLocal = (\n    localhostRegexp.test(remoteAddress) &&\n      (!req.headers['x-forwarded-for'] ||\n       _.all(req.headers['x-forwarded-for'].split(','), function (x) {\n         return localhostRegexp.test(x);\n       })));\n\n  // Determine if the connection was over SSL at any point. Either we\n  // received it as SSL, or a proxy did and translated it for us.\n  var isSsl = req.connection.pair ||\n      (req.headers['x-forwarded-proto'] &&\n       req.headers['x-forwarded-proto'].indexOf('https') !== -1);\n\n  if (!isLocal && !isSsl) {\n    // connection is not cool. send a 302 redirect!\n\n    // if we don't have a host header, there's not a lot we can do. We\n    // don't know how to redirect them.\n    // XXX can we do better here?\n    var host = req.headers.host || 'no-host-header';\n\n    // strip off the port number. If we went to a URL with a custom\n    // port, we don't know what the custom SSL port is anyway.\n    host = host.replace(/:\\d+$/, '');\n\n    res.writeHead(302, {\n      'Location': 'https://' + host + req.url\n    });\n    res.end();\n    return;\n  }\n\n  // connection is OK. Proceed normally.\n  var args = arguments;\n  _.each(oldHttpServerListeners, function(oldListener) {\n    oldListener.apply(httpServer, args);\n  });\n});\n\n\n// NOTE: this doesn't handle websockets!\n//\n// Websockets come in via the 'upgrade' request. We can override this,\n// however the problem is we're not sure if the websocket is actually\n// encrypted. We don't get x-forwarded-for or x-forwarded-proto on\n// websockets. It's possible the 'sec-websocket-origin' header does\n// what we want, but that's not clear.\n//\n// For now, this package allows raw unencrypted DDP connections over\n// websockets.\n"]}